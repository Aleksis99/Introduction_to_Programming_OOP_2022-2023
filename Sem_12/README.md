# Множествено наследяване
Множественото наследяване позволява един клас да наследи множество класове.

![alt_text](https://i.ibb.co/zGscdZ9/Multiple-Inheritance.png)

### Конструктори и деструктори при множествено наследяване:
```c++
struct MyClass : SuperClass1, SuperClass2, SuperClass3, SuperClass4
{
	MyClass()
	{
		std::cout << "MyClass()" << std::endl;
	}
	~MyClass()
	{
		std::cout << "~MyClass()" << std::endl;
	}
};

int main()
{
	MyClass obj;
}
```

![alt_text](https://i.ibb.co/82xJ2JK/Constr-destr-Mult-Inh.png)

### Копиране при множествено наследяване:
```c++
MyClass(const MyClass& other) : SuperClass1(other), SuperClass2(other), SuperClass3(other), SuperClass4(other)
{
	copyFrom(other);
}

MyClass(const MyClass& other)
{
	if (this != &other)
	{
		SuperClass1::operator=(other);
		SuperClass2::operator=(other);
		SuperClass3::operator=(other);
		SuperClass4::operator=(other);

		free();
		copyFrom(other);
	}
}
```

## Диамантен проблем
**Проблем**: Многократно наследяване на базов клас - нееднозначност при използване на данните му. В класа **D** има два обекта от тип **A**. Искаме характеристиките на **А**  да бъдат наследени **само веднъж**.

![alt_text](https://i.ibb.co/VW52qKC/Diamond.jpg)

Преодоляването на голяма част от недостатъците на многократното наследяване на клас се осъществява чрез използване на т.н. **виртуални основни класове**. Когато базов клас е обявен за виртуален, всички класове, които го наследяват, **споделят единствено негово копие**.

Обявяваме класа A за виртуален базов клас по следния начин:
```c++
// Syntax 1
class B : virtual public A 
{
};

// Syntax 2
class C : public virtual A
{
};
``` 

```c++
struct A
{
	int a = 4;
};

struct B : virtual A 
{
};

struct C : virtual A 
{
};

struct D : B, C 
{
	void f()
	{
		a++; // OK! No ambiguity!
	}
};
```

Конструкторите с параметри на виртуални класове трябва да се извикват от конструкторите на всички класове, които са техни наследници, а не само от конструкторите на преките им наследници.

```c++
D::D(...) : B(...), C(...), A(...) {} // We call the constructor of A explicitly.
```

# Задача 1 
## От контролно 2021
При решаването на задачата можете да използвате наготово:

- std::string и
- std::vector

Работата с паметта е ваша отговорност. За класовете реализирайте всички необходими компоненти, за да гарантирате коректната работа на вашата програма във всички тестови сценарии. В контролното ще се оценява архитектурното решение, което сте реализирали.

## Реализирайте клас Vehicle (превозно средство). То трябва да има следните член-данни:
- regnum - регистрационен номер, константа от тип низ.
За класа да се реализират подходящи конструктори.

## Програмата трябва да работи със следните превозни средства - леки коли (car) и камиони (truck).
 Леките коли имат брой пътници, които могат да превозват и булева стойност, която показва дали водачът е възпитан. Камионите имат поле за товароносимост (load capacity). Колите и камионите заемат определено пространство, когато бъдат паркирани и за него се плаща определена цена. Цената, която се заплаща за паркиране на съответното превозно средство се пресмята по следния начин:

- Цената за паркиране на камион е равна на товароносимостта му разделена на 100. 
- Ако шофьорът на колата е възпитан, той може да се възползва от специална префериaнциална цена - 1 лев. Ако това не е така, цената е
между 2 и 10 лева. Точната стойност се определя на случаен принцип при паркирането (използвайте функцията rand())

## Реализирайте клас Garage (гараж). 
Класът трябва да представя реален гараж, в който може да се паркират различни коли и камиони. За класа да се реализират подходящи конструктори и методи за добавяне на ново превозно средство към него. Гаражът трябва да може да побира колкото е нужно на брой коли.

## Да се реализира клас Minibus (микробус). 
Класът представя специално хибридно превозно средство, което прилича на лек автомобил, притежава същите характеристики, но може да превозва и товари. Микробусът има и допълнителна характеристика - брой на вратите. Да се реализират подходящи конструктори за класа.

## Микробусът може да паркира срещу сума, която се изчислява като средно-аритметичното на сумата, за която би паркирал камион със същите характеристики (товароносимост) и сумата за лека кола с тази характеристика за шофьора.

## Реализирайте главна функция, която създава гараж и множество от камиони, коли и микробуси, които да бъдат паркирани в него. Да се реализира функция, която намира общата сума, която притежателят на гаражът ще получи от паркираните в него автомобили.
