! В решенията не може да се използва std::string;  
! std::vector може да се използва в решението;  
  

**Задача 1**  
Да се реализира календар от събития който представлява колекция от различни събития.  
Всяко събитие се състои от име (name) и описание (description).  
Всяко име трябва да бъде низ с произволна дължина.  
Различават се четири типа събития:  
Съответно могат да се се образуват различават 4 различни типа двойки:

1.  Само със име - низът е с произволна дължина  
    Пример:  
    име: stringId  
    описание: Hello World
    
2.  Със име и дата  
    Пример:  
    име: First uni day  
    дата: 02 12 1999 
    описание: Hello World 2
    
3.  Със име и начално време време 
    Пример:  
    име: Work day start
    време: 13 55
    описание: Hello World 3
    
3.  Със име, дата и  начално време време 
    Пример:  
    име: OOP exam  
    дата: 02 12 1999 
    време: 13 55
    описание: Hello World 4
    

  

Коректността на входа за датата и времето НЕ е гарантирана. При валидацията за датата може да приемете, че дните във всички месеци са 31. При подадени невалидни стойности, същите се заменят с валидна стойност по подразбиране - 31 за ден, 12 за месец, 00:00 за време и се извежда подходящо съобщение.

  

Да се реализира функция която принтира колекцията


**Задача 2**

1)Освен конструктора по подразбиране (default
constructor), кои други функции влизат в “голя-
мата четворка” (функциите от т.нар. “rule-of-3”)?
Да се попълнят имената им в полетата долу:

```
___________________________________
___________________________________
___________________________________
```
2)Нека е дадена дефиницията:

```c++
class foo {
public:
virtual void f() {};
void g() {};
};
```
Срещу всеки от редовете, които извикватfили
g, да се запише “статично” или “динамично” спо-
ред вида свързване, който ще се използва за тях.

```c++
foo obj;
foo& ref = obj;
obj.f(); ____________________
obj.g(); ____________________
ref.f(); ____________________
ref.g(); ____________________
```
3)Нека са дадени следните дефиниции:

```c++
class base {
public: int a;
private: int b;
};
class derived : protected base { };
```
Да се посочи каква ще бъде видимостта на про-
менливите a и b в класа derived – public,
protected или private.

- Видимост на a:
- Видимост на b:

4)Нека класът X е абстрактен. Срещу всяко от
твърденията да се посочи “да” или “не” според
това дали е вярно:

- Могат да се създават обекти от тип X:
- Могат да се създават референции (reference)
    към обекти от тип X:

5)Нека е дадена следната дефиниция:
```c++
struct s {
public:
static int var;
s() { var = 5; }
};
int s::var = 0;
Да се посочи какво ще изведе следният фрагмент:
std::cout << ’(’ << s::var << ’)’;
s obj1;
obj1.var = 10;
s obj2;
std::cout << ’-’ << s::var << ’-’;
```
```
6)Да се допълни дефиницията на класаtest, та-
ка че функциятаfда бъде чиста виртуална (pure-
virtual) и класът да може коректно да се използва
като основа на полиморфна йерархия.
```
```c++
class test {
public:
_____________ void f() ______________;
______________________________________
};
```
7)Да се допълни дефиницията на шаблонаArray,
така че функциятаtestда се компилира корект-
но и да извежда на стандартния изход 55.
```c++
____________ <____________>
class Array {
static const size_t size = 10;
T data[size];
public:
____________ at(size_t index) {
if (index _____________________)
throw std::out_of_range("error");
return data[index];
}
};
```
```c++
void test() {
Array<int> a;
a.at(0) = 5;
std::cout << a.at(0);
Array<Array<int>> b;
b.at(0) = a;
std::cout << b.at(0).at(0);
}
```

**Задача 3**

Задачата да се реши на езика C++. Дадени са
дефинициите:
```c++
class A {
public:
A() { cout << "A()\n"; }
A(A&) { cout << "A(A&)\n"; }
virtual ~A() { cout << "~A()\n"; }
A& operator=(A&) {
cout << "op=(A&)\n";
return *this;
}
};

class B : public A {
public:
B() { cout << "B()\n"; }
B(B&) { cout << "B(B&)\n"; }
virtual ~B() { cout << "~B()\n"; }
B& operator=(B&) {
cout << "op=(B&)\n";
return *this;
}
};

void f(A b) { cout << "f(A)\n"; }
```
Под всеки от редовете на дадения вдясно програ-
мен фрагмент да се посочи какво ще се изведе
в резултат от неговото изпълнение. (Между ре-
довете нарочно е оставено повече място, за да
може да попълните отговора си) Ако смятате, че
някой ред няма да изведе нищо, напишете “не
извежда нищо”. Ако смятате, че някой от редо-
вете ще предизвика грешка, напишете “грешка”
и обяснете каква е тя и защо възниква.
За коректни се считат отговорите, които на-
пълно съответстват на това, което ще се случи
за съответния ред. Текст “грешка” без обяснение
носи нула точки.


```c++
B d;
```
```
B copy = d;
```
```
A b = d;
```
```
A& ref = d;
```
```
B arr[2];
```
```
f(d);
```
```
A* p = new B(d);
```
```
delete p;
```
```
d = d;
```
```
ref = d;
```
