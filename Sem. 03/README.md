# Класове. Член-функции. Модификатори за достъп. Капсулация.

```c++
struct DynamicArray
{
	int* data;
	size_t used;
	size_t allocated;
};

void initialise(DynamicArray& da)
{
	da.data = nullptr;
	da.used = 0;
	da.allocated = 0;
}
void free(DynamicArray& da)
{
	delete[] da.data;
	da.data = nullptr;
	da.used = 0;
	da.allocated = 0;
}
void allocate(DynamicArray& da, size_t size)
{
	da.data = new int[size];
	da.used = 0;
	da.allocated = size;
}

int& at(DynamicArray& da, size_t index)
{
	assert(index < da.used);
	return da.data[index];
}

int main()
{
	DynamicArray da;
	initialise(da);
}
```
Горният програмен фрагмент е напълно валиден.  
Но всички написани функции се отнасят за структурата DynamicArray. Не можем ли да ги "групираме" по някакъв начин?  

## Член-функции

- Функции, които **не съществуват глобално**.
- Имената им са от вида **\<StructName\>::\<memberFunctionName\>**
- **Работят с член-данните на инстанцията/обекта** от дадена структура/клас.
- **Извикват се с инстанция/обект** на структурата/класа.
- Компилаторът преобразува всяка член-функция на дадена структура/клас в обикновена функция с уникално име и един допълнителен параметър –**указател към инстанцията/обекта**.

**Константни член-функции**:

- **Не променят член-данните** на структурата/класа.
- Обозначават се чрез записване на ключовата дума **const**  в декларацията и в края на заглавието в дефиницията им.
- Могат да се извикват от **константни обекти**.

```c++
struct DynamicArray
{
	int* data;
	size_t used;
	size_t allocated;

	void initialise() // inline function
	{
		data = nullptr;
		used = 0;
		allocated = 0;
	}
	void free()
	{
		delete[] data;
		data = nullptr;
		used = 0;
		allocated = 0;
	}
	void allocate(size_t size)
	{
		data = new int[size];
		used = 0;
		allocated = size;
	}

	int& at(size_t index)
	{
		assert(index < used);
		return data[index];
	}
};

int main()
{
	DynamicArray da;
	da.initialise();
	da.allocate(100);
	da.at(5) = 22;
}
```

:bangbang: Инстанция на структурата DynamicArray заема място в паметта колкото за три променливи (data, used, allocated) :bangbang:  
Функциите живеят като глобални (**само на едно място**).  

Всяка член-функция, скрито от нас, получава като аргумент специална променлива (**this**) - **пойнтър към текущия обект, с който функцията работи**.  
Можем да си мислим, че нещата изглеждат така:  
(Долният програмен фрагмент няма да се компилира! Той е за нашата интуиция !!)  
```c++
{
	// ...
	void initialise(DynamicArray* this)
	{
		this->data = nullptr;
		this->used = 0;
		this->allocated = 0;
	}
	// ...
};
	
int main()
{
	DynamicArray da;
	DynamicArray::initialise(&da);
	// ...
}
```

Сега, искаме "външният свят" да **няма достъп до всички член-данни и методи на даден клас**. Това е така, защото тяхната промяна може да доведе до неочаквано поведение на нашата програма. Как можем да го постигнем?  

## Конструктори и деструктор.

**Жизнен цикъл на обект**:
 - Създаване на обект в даден scope – заделя се памет и член-данните се инициализират.
 - Достига се до края на скоупа(област).
 - Обектът и паметта, която е асоциирана с него се разрушава.

**Конструктор**:
 - Извиква се веднъж - при създаването на обекта.
 - Не се оказва експлицитно тип на връщане (връща констатна референция).
 - Има същото име като класа.
 
 **Деструктор**:
 - Извиква се веднъж - при изтриването на обекта.
 - Не се оказва експлицитно тип на връщане.
 - Има същото име като класа със симовла '~' в началото.

 ```c++

#include <iostream>

using namespace std;


struct Test 
{
  Test()
  {
  	cout << "Object is created" <<endl;
  }
  
 ~Test()
  {
  	cout << "Object is destroyed" <<endl;
  }
  int a;
  int b;
};

int main()
{
	while ()
	{
		Test t;// Object is created 
		if ()
		{
			Test t2; // Object is created 

		}// Object is destroyed (t2)

	}//Object is destroyed (t)
}

 ```
 ## Капсулация (encapsulation).
Понякога искаме потребителите да **нямат достъп до всички член-данни и методи на даден клас**.
Това е така, защото тяхната промяна може да доведе до **неочаквано поведение** на нашата програма. Принципът за **капсулация** ни помага като позволява да определим кои методи и атрибути може да използват потребителите на нашия клас.

 **Модификатор за достъп**:
 
| Модификатор за достъп: | Достъп:                         |
|------------------------|---------------------------------|
| private                | В текущия клас.                 |
| protected              | В текущия клас и *наследниците. |
| public                 | За всеки                        |

**Пример за get-ъри и set-ъри**

 ```c++

#include <iostream>

using namespace std;


struct Student 
{
private:
	int grade;
	int age;
public:
	Student(int grade, int age)
	{
		setGrade(grade);
		setAge(age);
	}
	int getGrade()
	{
		return grade;
	}
	int getAge()
	{
		return age;
	}
	void setGrade(int grade)
	{
		if(grade >= 2 && grade <= 6)
			this->grade = grade;
	}
	int setAge(int age)
	{
		if(age >= 0)
			this->age = age;
	}
};

int main()
{
	while ()
	{
		Test t;// Object is created 
		if ()
		{
			Test t2; // Object is created 

		}// Object is destroyed (t2)

	}//Object is destroyed (t)
}

 ```


## Задачи

**Задача 1:**
Реализирайте клас/структура интервал, който представлява интервал  [a,b]  (задължително а <= b) от реалната права. Нашият интервал ще бъде дискретен - началото и краят му ще бъдат цели числа и ще разглеждаме само точки, които са цели числа. Релизирайте следният интерфейс:

 - Подразбиращ се контруктор, който създава интервала **[0,0]**.
 - Конструктор, който приема двата параметъра. Ако a<=b, то създава интервала **[a,b]**. В противен случай, създава **[0,0]**.
 - Член-функция, която връща **дължината на интервала**.
 - Член-функция, която приема число и проверява **дали е част от интервала**.
 - Член-функция, която връща **броя на простите числа** в интервала.
 - Член-функция, която връща **броя на числата в интервала**, които са палиндорми.
 - Член-функция, която връща **броя на числата, които нямат повтарящи цифри**.
 - Член-функция, която връща дали началото и края на интервала са **степени на 2-ката**. ([2,16] - истина) 
 - Член-функция, която приема интервал и връща **сечението на текущия интервал с подадения**.  (Сечението на [1, 5]  [3, 7]  e [3, 5]).
 - Член-функция, която приема интервал и връща дали подадения (като параметър) интервал е **подинтервал на текущия**(обектът, от който се извиква функцията).

  **Пример за работа с класа:**
 ```c++

int main()
{
     Interval t1(3,10); // [3, 10]
     Interval t2(4,14); // [4, 14]
     Interval t3; // [0, 0]

     Interval result = t1.intersect(t2); // [4, 10]
     
     t2.isSuperInterval(result); //true
     
     result.calcPrimeNumbersInTheInterval() // 2 (only 5 and 7)
}
 ```


